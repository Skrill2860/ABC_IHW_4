# Индивидуальное домашнее задание №4, вариант 12.
## Порошин Илья БПИ219
Доброго времени суток!\
В этом докУменте я написал как оно запускалось, может у вас тоже запустится, если пойдете тем же путем.\
Если нет - я не виноват.\
Наверное.\
А, ну и если все комманды повторять, то комментариев, очевидно, не будет, так как они перепишутся заново сгенерированными файлами.\
Так что не надо повторять XD\
У блоков есть ссылочки на папки, на них можно кликать. Еще есть тесты в папках **Tests**.
> Ссылочки работают в VSCode, возможно в Atom тоже, но я не проверял.

*Работа сделана на 8.*\

> Задание варианта 12:\
Задача о гостинице - 1. В гостинице 30 номеров, клиенты гостиницы снимают номер на одни или несколько суток. Если в гостинице нет свободных номеров, клиенты не уходят, а устраиваются на рядом с гостиницей на скамейках и ждут, пока любой номеров не освободится. Создать многопоточное приложение, моделирующее работу гостиницы.

## На 4:
- Решение на C находится в [**ihw_3_4.c**](./4/ihw_3_4.c)
- Для создания .s файла были использованы следующие опции компиляции:
```sh
$ gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none -no-pie -fno-stack-protector -o ihw_3_4.s ihw_3_4.c
```
- Для компиляции не использовались опции компиляции вообще:
```sh
$ gcc ihw_3_4.c -o ihw_3_4_c.out
```
- Сгенерированный .s файл [**ihw_3_4.s**](./4/ihw_3_4.s) прокомментирован, в общих чертах написано что за что отвечает.
- Скомпилировал [**ihw_3_4.s**](./4/ihw_3_4.s). Опции компиляции - на 4 сказано чтоб без них надо (ну то есть опций то много было использовано выше, но оптимизации отключены и нет опций отладки):
```
$ gcc ihw_3_4.s -o ihw_3_4_s.out
```

> Тесты и их результаты для обеих программ представлены в папке [**Tests**](./4/Tests/)\
 В [*tests.txt*](./4/Tests/tests.txt) лежат тесты.\
В файле [*c_out.txt*](./4/Tests/c_out.txt) вывод программы на C.\
В файле [*s_out.txt*](./4/Tests/s_out.txt) вывод программы на GAS.\
Выводы одинаковые, значит с большой вероятностью программы работают одинаково.
## На 5 и 6:
- Файл на языке C [**ihw_3_6.c**](./5-6/ihw_3_6.c) тот же, что и для пункта 4, в нем есть и функция с параметрами, и локальные переменные. А вот ассемблерный файл [**ihw_3_6.s**](./5-6/ihw_3_6.s) уже изменился: необходимые комментарии про параметры функции и комментарии при её вызове добавлены, также программа была оптимизирована под использование регистров. Оптимизирована только функция подсчета, т.к. она самая "тяжелая" вплане вычислений, а мейн достаточно короткий и смысла в оптимизации особо нет. Также все замены на регистры и суть их использования подробно прокомментированы.
- Скомпилировал [**ihw_3_6.c**](./5-6/ihw_3_6.c) без оптимизаций и всего такого:
```sh
$ gcc -O0 -Wall -fno-asynchronous-unwind-tables -fcf-protection=none -no-pie -fno-stack-protector ihw_3_6.c -o ihw_3_6_c.out
```
- Скомпилировал [**ihw_3_6.s**](./5-6/ihw_3_6.s):
```
$ gcc ihw_3_6.s -o ihw_3_6_s_opt.out
```
> Тесты те же. Лежат они также в папке [**Tests**](./5-6/Tests/)\
В [*tests.txt*](./5-6/Tests/tests.txt) находятся сами тесты.\
В файле [*c_out.txt*](./5-6/Tests/c_out.txt) вывод программы на C.\
В файле [*s_opt_out.txt*](./5-6/Tests/s_opt_out.txt) вывод программы на GAS.\
Выводы одинаковые, так что вроде все ок.
- Осталось сравнить размеры исполняемых файлов [**ihw_3_6_c.out**](./5-6/ihw_3_6_c.out) и [**ihw_3_6_s_opt.out**](./5-6/ihw_3_6_s_opt.out).
```
$ ls -l ihw_3_6_c.out ihw_3_6_s_opt.out
=> ihw_3_6_c.out 16512
=> ihw_3_6_s_opt.out 16576
```
> Итого оптимизированная программа стала занимать на 64 байта больше.

## На 7:
- Программа разделена на две единицы компиляции: В первом файле [**main.c**](./7/main.c) находится мейн, во втором файле [**my_math.c**](./7/my_math.c) находится функция подсчета.
- Компиляция через C-файлы:
```sh
$ gcc -c my_math.c -o my_math_c.o
$ gcc -c main.c -o main_c.o
$ gcc my_math_c.o main_c.o -o ihw_3_7_c_sep.out
```
- Компиляция через ассемблерные файлы:
```sh
$ gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none -no-pie -fno-stack-protector -o my_math.s my_math.c
$ gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none -no-pie -fno-stack-protector -o main.s main.c
$ as my_math.s -o my_math_s.o
$ as main.s -o main_s.o
$ gcc my_math_s.o main_s.o -o ihw_3_7_s_sep.out
```
- Пример использования (сначала С, потом GAS):\
Первым параметром указывается входной файл, вторым - файл куда будет записан вывод (создастся сам если такого нет).
```sh
$ ./ihw_3_7_c_sep.out Tests/test1.txt output1_c.txt
$ ./ihw_3_7_s_sep.out Tests/test1.txt output1_s.txt
```
>Тесты лежат в папке [**Tests**](./7/Tests/).\
В [*tests.txt*](./7/Tests/tests.txt) находятся все тесты сразу.\
В файле [*c_out.txt*](./7/Tests/c_out.txt) все выводы программы на C. Они собраны в один файл, чтобы было проще сравнивать с ассемблером.\
В файле [*s_out.txt*](./7/Tests/s_out.txt) все выводы программы на GAS. Тоже собраны в один файл.\
Все выводы получены с помощью запуска программ через питон. Конечное слияние файлов со сравнением выводов тоже делал питоном (до этого из консоли ctrl c ctrl v было быстро, а тут файлы открывать руками долговато). В итоге файлы одинаковы, так что выводы тоже одинаковы.

## На 8:
- Программа разделена так же как и в п.7. В первом файле [**main.c**](./8/main.c) находится мейн, во втором файле [**my_math.c**](./8/my_math.c) находится функция подсчета. Но теперь изменен ввод, чтобы можно было использовать рандом + [*ассемблерный файл с функцией подсчета корня*](./8/my_math_reg_opt.s) оптимизирован с использованием регистров.
- Для начала про новый ввод:\
Теперь сначала нужно указать букву 'r' или 'f' (от random или file).\
Если выбран рандом, то вторым параметром к нему можно опционально указать seed (по умолчанию seed случайный) и третьим параметром - количество повторов подсчета корня (функция будет вызвана для одного и того же числа, потому seed в этом случае обязательный параметр - для справедливых замеров времени выполнения обеих программ). Вывод осуществляется в файл output_random.txt\
Если выбран файловый ввод (он в основе не поменялся), то первым параметром указывается входной файл, вторым - файл куда будет записан вывод (создастся сам если такого нет), третьим - количество повторов подсчета корня.
- Программа теперь считает время выполнения функции (воемя всех её повторений в сумме) и выводит его в консоль.\
- Компиляция через C-файлы:
```sh
$ gcc -c my_math.c -o my_math_c.o
$ gcc -c main.c -o main_c.o
$ gcc my_math_c.o main_c.o -o ihw_3_8_c_unopt.out
```
- Компиляция через ассемблерные файлы ([*my_math_reg_opt.s*](./8/my_math_reg_opt.s) - оптимизированная через регистры функция):
```sh
$ gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none -no-pie -fno-stack-protector -o my_math.s my_math.c
$ gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none -no-pie -fno-stack-protector -o main.s main.c
$ as my_math_reg_opt.s -o my_math_s_reg_opt.o
$ as main.s -o main_s.o
$ gcc my_math_s_reg_opt.o main_s.o -o ihw_3_8_s_opt.out
```
- Пример использования (сначала С, потом GAS):\
Первым параметром указывается входной файл, вторым - файл куда будет записан вывод (создастся сам если такого нет).
```sh
# random number, random seed
$ ./ihw_3_8_c_unopt.out r
# number is not really random, seed 1
$ ./ihw_3_8_c_unopt.out r 1
# number is not really random, seed 1, 1000 repetitions
$ ./ihw_3_8_c_unopt.out r 1 10000000
# input from input.txt, output to file output.txt, 10000000 repetitions
$ ./ihw_3_8_c_unopt.out f input.txt output.txt 10000000

# same for GAS, but with ihw_3_8_s_opt.out elf 
$ ./ihw_3_8_s_opt.out r 1 10000000
$ ./ihw_3_8_s_opt.out f input.txt output.txt 10000000
```

### 1) Для замеров был использован seed = 2 (number = 5335442), количество повторов = 20000000.
Время указано в секундах:

Run     | Unoptimized C | Optimized GAS | Delta (C-GAS) |
:------ |:------------- |:------------- |:------------- |
1       |   6.265625    |   6.015625    | 0.25          |
2       |   6.593750    |   6.046875    | 0.546875      |
3       |   6.437500    |   6.031250    | 0.40625       |
4       |   6.296875    |   6.218750    | 0.078125      |
5       |   6.343750    |   6.031250    | 0.3125        |
6       |   6.281250    |   6.171875    | 0.109375      |
7       |   6.406250    |   6.109375    | 0.296875      |
8       |   6.296875    |   6.046875    | 0.25          |
Average |  6.365234375  |  6.083984375  | 0.28125       |

- Код на Python для пересчета:
```python
arrC = [6.265625, 6.593750, 6.437500, 6.296875, 6.343750, 6.281250, 6.406250, 6.296875]
arrGAS = [6.015625, 6.046875, 6.031250, 6.218750, 6.031250, 6.171875, 6.109375, 6.046875]
arrDelta = [arrC[i] - arrGAS[i] for i in range(8)]
print(sum(arrC) / len(arrC))
print(sum(arrGAS) / len(arrGAS))
print(sum(arrDelta) / len(arrDelta))
```
>Как видно из таблицы, оптимизация через регистры дала прирост в скорости выполнения функции в среднем на 0.28125 секунды.
При 70000000 (70 миллионов) повторов, это дает прирост в 0.8 секунды (23.875000 - 23.078125).

### 2) Для замеров было использовано число 10000 (гораздо меньшее чем при рандоме ранее), количество повторов = 40000000.\
Время указано в секундах:

Run     | Unoptimized C | Optimized GAS | Delta (C-GAS)|
:------ |:------------- |:------------- |:------------ |
1       |   6.312500    |   7.453125    | -1.140625    |
2       |   6.234375    |   7.421875    | -1.1875      |
3       |   6.125000    |   7.765625    | -1.640625    |
4       |   6.312500    |   7.531250    | -1.21875     |
5       |   6.125000    |   7.421875    | -1.296875    |
6       |   6.328125    |   7.468750    | -1.140625    |
7       |   6.140625    |   7.468750    | -1.328125    |
8       |   6.156250    |   7.500000    | -1.34375     |
Average |  6.216796875  |  7.50390625   | -1.287109375 |

- Код на Python для пересчета:
```python
arrC = [6.312500, 6.234375, 6.125000, 6.312500, 6.125000, 6.328125, 6.140625, 6.156250]
arrGAS = [7.453125, 7.421875, 7.765625, 7.531250, 7.421875, 7.468750, 7.468750, 7.500000]
arrDelta = [arrC[i] - arrGAS[i] for i in range(8)]
print(sum(arrC) / len(arrC))
print(sum(arrGAS) / len(arrGAS))
print(sum(arrDelta) / len(arrDelta))
```
>При не слишком большом числе number и огромном числе повторов оптимизация сработала в обратную сторону и замедлила программу в среднем на 1.287 секунды. Это очень много, учитывая, что время выполнения в целом составляет около 6-7 секунд. Программа работает примерно на 20% медленнее.

## Вывод: у оптимизированной программы преимущество при больших числах и малом количестве повторов. Функция работает быстрее, но её вызов стал более тяжелым, потому огромное количество повторов приводит к замедлению программы.

# Спасибо за проверку!